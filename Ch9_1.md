# 9. 옵티마이저와 힌트
하나의 쿼리는 여러 방법으로 실행될 수 있다. 다양한 방법 중에 어떤 방법이 최적이고 최소의 비용이 소모될지 예측하고 결정해야 하는데, 이 역할을 하는 것이 옵티마이저이다.

## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. 사용자가 요청한 SQL 문장을 MySQL 서버가 이해할 수 있게 파싱한다.
2. SQL의 파싱 정보를 확인하며, 어떤 테이블부터 읽고 어떤 인덱스를 사용할지 결정한다.
3. 단계 2에서 결정한 방법으로 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저의 종류
1) 옵티마이저에 내장된 우선순위에 따라 실행하는 규칙 기반 최적화
2) 통계정보(테이블의 레코드 건수나 칼럼값의 분포도)를 활용하는 비용 기반 최적화

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
#### 풀 테이블 스캔
- 테이블의 레코드 건수가 너무 작아 인덱스를 통해 읽는거보다 풀 테이블 스캔이 효율적일때
- 주어진 조건으로 인덱스를 탈 수 없을 때
- 인덱스 레인지 스캔을 사용할 수 있어도 레코드 건수가 너무 많을 때

InnoDB 스토리지 엔진은 풀 테이블 스캔을 할 경우 리드어헤드(Read Ahead)라는 기능을 이용한다.
- 리드어헤드: 어떤 영영의 데이터가 앞으로 필요해지리라는 것을 예측해 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
- InnoDB의 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
- 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하면 되기 때문에 쿼리가 빨라진다.

#### 풀 인덱스 스캔
- 인덱스를 처음부터 끝까지 스캔하는 것을 의미하고, 레코드 건수를 조회할 때 사용될 수 있다.

### 9.2.2 병렬 처리
MySQL 8.0부터 하나의 쿼리를 여러 개의 스레드로 처리할 수 있다.
병렬 처리용 스레드 개수가 늘어날 수록 쿼리 처리에 걸리는 시간이 줄어들지만, CPU 코어 개수를 넘개 설정하며 오히려 성능이 떨어질 있으니 주의!

### 9.2.3 ORDER BY 처리(Using filesort)
정렬을 처리하는 방법
1) 인덱스 이용
2) Filesort 이용

File sort를 사용하는 경우
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- Group by 결과 또는 Distinct 같은 처리의 결과를 정렬해야 하는 경우
- Union의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

#### 9.2.3.1 소트 버퍼
- 소트 버퍼: MySQL이 정렬을 수행하기 위해 할당받는 별도의 메모리 공간. 쿼리의 실행이 완료되면 즉시 시스템으로 반납되고, 세션(로컬) 메모리 영역이다.

- 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 많다면, 임시 저장을 위해 디스크를 사용하기 때문에 오래걸리게 된다. 
  - 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록
  - 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하며 정렬을 수행
- 소트 버퍼를 크게 설정하면 디스크 I/O를 줄일 수 있다. 따라서 데이터가 많거나 디스크 I/O의 성능이 낮은 장비라면 소트 버퍼의 크기를 더 크게 설정하는게 도움이 될 수 있다. 하지만 너무 크게 설정하면 서버의 메모리가 부족해지는 현상이 올 수 있다. 

#### 9.2.3.2 정렬 알고리즘
##### 싱글패스
- 레코드 전체를 소트 버퍼에 담는 방법
  - 더 많은 소트 버퍼 공간이 필요
  - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임
##### 투패스
- 정렬 기준 칼럼만 소트 버퍼에 담는 방법. 
  - 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select할 칼럼을 가져온다.
  - 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적