# 9. 옵티마이저와 힌트
하나의 쿼리는 여러 방법으로 실행될 수 있다. 다양한 방법 중에 어떤 방법이 최적이고 최소의 비용이 소모될지 예측하고 결정해야 하는데, 이 역할을 하는 것이 옵티마이저이다.

## 9.1 개요
### 9.1.1 쿼리 실행 절차
1. 사용자가 요청한 SQL 문장을 MySQL 서버가 이해할 수 있게 파싱한다.
2. SQL의 파싱 정보를 확인하며, 어떤 테이블부터 읽고 어떤 인덱스를 사용할지 결정한다.
3. 단계 2에서 결정한 방법으로 스토리지 엔진으로부터 데이터를 가져온다.

### 9.1.2 옵티마이저의 종류
1) 옵티마이저에 내장된 우선순위에 따라 실행하는 규칙 기반 최적화
2) 통계정보(테이블의 레코드 건수나 칼럼값의 분포도)를 활용하는 비용 기반 최적화

## 9.2 기본 데이터 처리
### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
#### 풀 테이블 스캔
- 테이블의 레코드 건수가 너무 작아 인덱스를 통해 읽는거보다 풀 테이블 스캔이 효율적일때
- 주어진 조건으로 인덱스를 탈 수 없을 때
- 인덱스 레인지 스캔을 사용할 수 있어도 레코드 건수가 너무 많을 때

InnoDB 스토리지 엔진은 풀 테이블 스캔을 할 경우 리드어헤드(Read Ahead)라는 기능을 이용한다.
- 리드어헤드: 어떤 영영의 데이터가 앞으로 필요해지리라는 것을 예측해 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
- InnoDB의 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 리드 어헤드 작업이 자동으로 시작된다.
- 포그라운드 스레드는 미리 버퍼 풀에 준비된 데이터를 가져다 사용하면 되기 때문에 쿼리가 빨라진다.

#### 풀 인덱스 스캔
- 인덱스를 처음부터 끝까지 스캔하는 것을 의미하고, 레코드 건수를 조회할 때 사용될 수 있다.

### 9.2.2 병렬 처리
MySQL 8.0부터 하나의 쿼리를 여러 개의 스레드로 처리할 수 있다.
병렬 처리용 스레드 개수가 늘어날 수록 쿼리 처리에 걸리는 시간이 줄어들지만, CPU 코어 개수를 넘개 설정하며 오히려 성능이 떨어질 있으니 주의!

### 9.2.3 ORDER BY 처리(Using filesort)
정렬을 처리하는 방법
1) 인덱스 이용
2) Filesort 이용

File sort를 사용하는 경우
- 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
- Group by 결과 또는 Distinct 같은 처리의 결과를 정렬해야 하는 경우
- Union의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

#### 9.2.3.1 소트 버퍼
- 소트 버퍼: MySQL이 정렬을 수행하기 위해 할당받는 별도의 메모리 공간. 쿼리의 실행이 완료되면 즉시 시스템으로 반납되고, 세션(로컬) 메모리 영역이다.

- 정렬해야 할 레코드의 건수가 소트 버퍼로 할당된 공간보다 많다면, 임시 저장을 위해 디스크를 사용하기 때문에 오래걸리게 된다. 
  - 메모리의 소트 버퍼에서 정렬을 수행하고, 그 결과를 임시로 디스크에 기록
  - 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장
  - 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하며 정렬을 수행
- 소트 버퍼를 크게 설정하면 디스크 I/O를 줄일 수 있다. 따라서 데이터가 많거나 디스크 I/O의 성능이 낮은 장비라면 소트 버퍼의 크기를 더 크게 설정하는게 도움이 될 수 있다. 하지만 너무 크게 설정하면 서버의 메모리가 부족해지는 현상이 올 수 있다. 

#### 9.2.3.2 정렬 알고리즘
##### 싱글패스
- 레코드 전체를 소트 버퍼에 담는 방법
  - 더 많은 소트 버퍼 공간이 필요
  - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임
##### 투패스
- 정렬 기준 칼럼만 소트 버퍼에 담는 방법. 
  - 정렬 대상 컬럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬을 수행하고, 정렬된 순서대로 다시 프라이머리 키로 테이블을 읽어서 select할 칼럼을 가져온다.
  - 정렬 대상 레코드의 크기나 건수가 많은 경우 효율적

#### 9.2.3.3 정렬 처리 방법
* ORDER BY를 위한 세 가지 처리 방법
	* 인덱스를 사용한 정렬 - 실행 계획의 Extra: 별도 표기 X
	* 조인에서 드라이빙 테이블만 정렬 (소트 버퍼로 정렬) - 실행 계획의 Extra: Using filesort
	* 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 - 실행 계획의 Extra: Using temporary; Using filesort
##### 9.2.3.3.1 인덱스를 이용한 정렬
* 전제 조건
	* ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블(조인하는 경우 드라이빙 테이블)에 속해야 한다.
	* ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
	* WHERE 절에 제일 먼저 읽는 테이블의 컬럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 타야 한다.
	* 사용할 인덱스가 해시 인덱스/전문 검색 인덱스/R-Tree 인덱스가 아닌 B-Tree 인덱스여야 한다.
	* 여러 테이블이 조인되는 경우, nested-loop 방식의 조인에서만 사용할 수 있다.
* 인덱스는 값이 정렬되어 있어서 결과 또한 정렬되어 있다.
* 조인은 nested-loop 방식으로 실행되므로 정렬된 결과가 나오지만, 조인이 사용된 쿼리의 실행 계획에 조인 버퍼(join buffer)가 사용되면 순서가 흐트러질 수 있다.

##### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
* 조인하는 경우 레코드 건수가 불어나고 레코드의 크기도 커지기 때문에 조인을 실행하기 전에 정렬을 하면 부하가 줄어든다. 이 방법을 사용하기 위해서는 드라이빙 테이블의 컬럼을 기준으로 ORDER BY 하는 쿼리여야 한다.
* 드라이빙 테이블만 검색해서 정렬을 먼저 수행하고 그 결과와 드리븐 테이블을 조인하는 방식으로 진행된다.

##### 9.2.3.3.3 임시 테이블을 이용한 정렬
* ‘조인의 드라이빙 테이블만 정렬’ 방식과 다르게 드리븐 테이블의 컬럼을 기준으로 ORDER BY 하는 쿼리의 결과를 정렬할 때는 조인할 때 임시 테이블을 사용한다. 이 임시 테이블의 결과를 정렬하는 방식이다.
* 실행 계획의 Extra: Using temporary; Using filesort -> 조인의 결과를 임시(temporary) 테이블에 저장하고, 그 결과를 다시 정렬 처리했음을 의미한다.

##### 9.2.3.3.4 정렬 처리 방법의 성능 비교
* LIMIT 이 걸려있더라도 ORDER BY나 GROUP BY를 하는 작업은 LIMIT 개수만큼만 가져와서 처리하는 것이 불가능하다.
* 인덱스를 활용하도록 튜닝하더라도 잘못된 ORDER BY나 GROUP BY 때문에 쿼리가 느려지는 경우가 많다.
* 인덱스를 사용하지 못하는 ORDER BY나 GROUP BY가 왜 느린지 알기 위해 쿼리가 처리되는 방식 두 가지를 살펴보자!

###### 9.2.3.3.4.1 스트리밍 방식
* 조건에 일치하는 레코드가 검색될 때마다 바로바로 클라이언트로 전송해주는 방식
* OLTP 환경에서는 쿼리를 요청하고 첫 번째 레코드를 전달받기까지의 응답 시간이 중요하다. 스트리밍 방식은 이 시간을 단축시켜준다.
* LIMIT이 걸린 쿼리는 스트리밍 방식을 통해 실행 시간이 상당히 단축된다.

###### 9.2.3.3.4.2 버퍼링 방식
* ORDER BY나 GROUP BY는 쿼리의 결과를 스트리밍 방식으로 처리할 수 없다.
* 응답 시간이 길기 때문에 클라이언트는 기다려야 한다.
* LIMIT 조건이 있어도 성능 향상에 별로 도움이 되지 않는다.
* JDBC
	* 스트리밍 방식으로 결과가 순차 전송되어도 내부 버퍼에 담아두었다가 모든 결과를 전달받으면 그때 클라이언트의 애플리케이션에 리턴한다.
	* 전체 처리 시간이 짧고, DB 서버와의 통신 횟수가 적어 자원 소모가 줄어들기 때문이다.
	* JDBC 디폴트 옵션은 버퍼링이지만 전송 방식을 스트리밍 방식으로 변경할 수 있다.
* 정렬 처리 방법 세 가지 중 ‘인덱스를 이용한 정렬’만 스트리밍 형태이고 나머지는 버퍼링된 후에 정렬된다.
* 정렬 처리 방법에 따라서 성능 차이가 크므로 가능하다면 ‘인덱스를 이용한 정렬’로 유도하고, 그게 안되면 최소 ‘조인의 드라이빙 테이블만 정렬’ 방법으로 유도하는 것도 좋은 튜닝 방법이다.

#### 9.2.3.4 정렬 관련 상태 변수
* Sort_merge_passes: 멀티 머지 처리 횟수
* Sort_range: 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
* Sort_scan: 풀 테이블 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
* Sort_rows: 지금까지 정렬한 전체 레코드 건수

### 9.2.4 GROUP BY 처리
* GROUP BY가 있는 쿼리에서는 HAVING 조건을 사용할 수 있다.
* HAVING 절을 튜닝해도 GROUP BY에 사용된 조건은 인덱스로 처리할 수 없다.

#### 9.2.4.1 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
*  조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 GROUP BY에서 사용하는 컬럼으로 생성된 인덱스가 있다면 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
* 인덱스를 통해 GROUP BY를 처리하는 경우에도 그룹 함수(COUNT, SUM, MAX, MIN 등) 등의 그룹값을 처리해야 해서 임시 테이블을 사용하기도 한다.
* 인덱스를 통해 GROUP BY를 처리하면 추가적인 정렬 작업이나 내부 임시 테이블이 필요 없으므로 실행 계획의 Extra에 “Using index for group-by” 나 “Using temporary, Using filesort” 같은 코멘트는 표시되지 않는다.

#### 9.2.4.2 루스 인덱스 스캔을 이용하는 GROUP BY
* 루스 인덱스 스캔: 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것
* 실행 계획의 Extra: Using index for group-by
```sql
SELECT emp_no FROM salaries
WHERE from_date = '1985-03-01'
GROUP BY emp_no;
```
* 위와 같은 `salaries`테이블에 `(emp_no, from_date)`로 생성된 인덱스가 있다고 생각해보자.
* 일단 인덱스 레인지 스캔 방식은 사용할 수 없다.
* 이 쿼리의 실행 과정
	1. `(emp_no, from_date)` 인덱스를 차례대로 스캔하면서 `emp_no`의 첫 번째 유니크 값 “10001” 을 찾는다.
	2. `(emp_no, from_date)` 인덱스에서 `emp_no`가 “10001” 인 것 중에서 `from_date` 값이 “1985-03-01” 인 레코드를 찾는다.
	3. `(emp_no, from_date)` 인덱스에서 `emp_no`의 그 다음 유니크 값을 가져와서 반복한다.
* Prefix index(컬럼값의 앞쪽 일부만으로 생성된 인덱스)는 루스 인덱스 스캔을 사용할 수 없다.
* 인덱스 레인지 스캔에서는 카디널리티가 높아야 성능이 좋지만, 루스 인덱스 스캔에서는 카디널리티가 낮아야 성능이 좋다.
* 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도의 임시 테이블이 필요 없다.
