# 9. 옵티마이저와 힌트
## 9.3 고급 최적화
MySQL 옵티마이저는 실행 계획을 수립할 때 통계정보와 옵티마이저 옵션을 사용한다.

### 9.3.1 옵티마이저 스위치 옵션
- 옵티마이저 스위치 옵션은 글로벌과 세션별로 모두 설정할 수 있는 변수이다. "SET_VAR" 옵티마이저 힌트를 이용해 현재 쿼리에만 설정하는 것도 가능하다.

#### 9.3.1.1 MRR(Multi-Range Read)과 배치 키 액세스(Batched Key Access)
*mrr & batched_key_access*
- MySQL 서버에서 사용되는 대부분의 조인 방식은 네스티드 루프 조인
  - 드라이빙 테이블의 레코드를 한 건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 것
- 이를 더 최적화 한 것이 BKA 조인
  - 드라이빙 테이블의 레코드를 읽어서 조인 버퍼에 버퍼링 해놓은 후, 조인 버퍼에 레코드가 가득차면 스토리지 엔진에 요청함
  - 읽어야 할 레코드들을 데이터 페이지에 정렬된 순서로 접근해 디스크 접근이 최소화된다
  - 부가적인 정렬이 필요해 성능에 오히려 악영향을 미칠 수 있으므로, 쿼리의 특성에 따라 사용여부를 결정해야 함

#### 9.3.1.2 블록 네스티드 루프 조인
*block_nested_loop*
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 차이점
  - 조인버퍼가 사용되는지
  - 드라이빙 테이블과 드리븐 테이블이 어떤 순서로 조인되는지
- 네스티드 루프
  - 조인의 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식
- 블록 네스티드 루프
  - 조인 버퍼
    - 드리븐 테이블을 검색할 때 인덱스를 사용할 수 없는 쿼리는 상당히 느려진다. 드리븐 테이블의 풀 테이블 스켄이나 인덱스 풀 스캔을 피할 수 없다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후, 드리븐 테이블과 이 메모리 캐시를 조인하는 형태로 처리한다. 이 때 사용되는 메모리 캐시를 조인 버퍼(Join buffer)라고 한다.
    - 조인 버퍼가 사용되는 쿼리에서는 조인의 순서가 거꾸로인 것처럼 실행된다. 따라서, 조인 버퍼가 사용되는 조인에서는 결과의 정렬 순서가 흐트러질 수 있다.

#### 9.3.1.3 인덱스 컨디션 푸쉬 다운 
*index_condition_pushdown*
- 체크조건이나 필터링 조건도 인덱스를 최대한 사용하는 옵션
- 예전에는 인덱스를 범위 제한 조건으로 사용하지 못하면 (Ex. like '%sal') 해당 조건은 MySQL엔진이 스토리지 엔진으로 전달하지 않아 무조건 레코드를 읽었는데, 이제는 인덱스에 포함된 칼럼의 조건이 있다면 다 모아서 스토리지 엔진으로 전달할 수 있도록 핸들러 API가 개선됨

#### 9.3.1.4 인덱스 확장
*use_index_extensions*
- InnoDB 스토리지 엔진에서, 모든 세컨더리 인덱스는 리프 노드에 프라이머리 키 값을 가지므로, 프라이머리 인덱스 칼럼을 포함한 것처럼 인덱스를 확장해 실행계획을 수립
- 별도의 정렬 작업 없이 인덱스 순서대로 레코드를 읽기만 하므로 정렬이 처리되는 장점도 있음

#### 9.3.1.5 인덱스 머지
*index_merge*
- 인덱스를 이용해 쿼리를 실행하는 경우, 대부분 옵티마이저는 테이블별로 하나의 인덱스만 사용하도록 실행 계획을 수립한다.
- 하지만, 쿼리에 사용된 각각의 조건이 서로 다른 인덱스를 사용할 수 있고, 그 조건을 만족하는 레코드 건수가 많을 것으로 예상될 때 MySQL 서버는 인덱스 머지 실행 계획을 선택한다.
- 종류
  - index_merge_intersection
  - index_merge_union
  - index_merge_sort_union
    

#### 9.3.1.6 인덱스 머지 - 교집합
*index_merge_intersection*
- 여러 개의 인덱스를 각각 검색해서 그 결과의 교집합만 반환

#### 9.3.1.7 인덱스 머지 - 합집합
*index_merge_union*
- 여러 개의 인덱스를 각각 검색해서 합집합을 반환
- 정렬된 두 집합의 결과를 하나씩 가져와 중복 제거를 수행 함 -> 우선순위 큐
```sql
 select * from employees
 where first_name='Matt' OR hire_date='2023-05-01';
```

#### 9.3.1.8 인덱스 머지 - 정렬 후 합집합
*index_merge_sort_union*
- 인덱스 머지 작업을 하는 도정에 결과의 정렬이 필요한 경우. 두 집합에의 결과에서 중복을 제거하기 위해 각 집합을 프라이머리 키로 정렬한 후 중복 제거를 수행 한다.
```sql
 select * from employees
 where first_name='Matt' 
 OR hire_date BETWEEN '2023-05-01' and '2023-05-05;
```

#### 9.3.1.9 세미 조인
*semijoin*
- 세미조인: 다른 테이블과 실제 조인을 수행하지는 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리
```sql
 select * from employees e where e.emp_no in (
    select de.dept_no from dept_emp de where de.from_date='2005-10-12'
);
```
- 기존의 MySQL은 아우터 테이블을 풀 스캔해 한건 한건 서브 쿼리의 조건에 일치하는지 비교했다.

#### 9.3.1.10 테이블 풀-아웃
*Table Pull-out*
- 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 형태의 최적화
```sql
 select * from employees e where e.emp_no in (
    select de.emp_no from dept_emp de where de.dep_no='d009'
);
```
- MySQL 옵티마이저는 위 쿼리를 아래와 같이 재작성함
```sql
 select * 
 from dept_emp de 
 join employees e 
 where e.emp_no = de.emp_no and de.dep_no='d009';
```

#### 9.3.1.11 퍼스트 매치
*firstmatch*
- in(subquery) 형태의 세미조인을 exists(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행
- firstmatch는 서브 쿼리에서 하나의 레코드만 검색되면 더 이상의 검색을 멈추는 단축 실행 경로이다.
- firstmatch 최적화에서 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
```sql
 select * 
 from employees e 
 where e.first_name='Matt'
 and e.emp_no in (
    select t.emp_no from titles t
    where t.from_date between '1995-01-01' and '1995-01-30'
    );
```

#### 9.3.1.12 루스 스캔
*loosescan*
- 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그 다음으로 아우터 테이블을 드리븐으로 사용해 조인을 수행한다.
```sql
 select * from departments d where d.dept_no in (
    select de.dept_no from dept_emp de
);
```
- 정보
  - dept_emp 테이블
    - 프라이머리 키 인덱스는 (dept_no, empt_no)
    - 전체 레코드 33만건
  - departments 테이블
    - 전체 레코드 9건
- 실행 계획
  - dept_emp 테이블을 드라이빙 테이블로 실행한 후, 프라이머리 키를 dept_no 부분에서 유니크하게 한 건만 읽는다.
